// ===================================================================
// GOOGLE PROTOCOL BUFFERS (PROTOBUF) EXAMPLE
// ===================================================================
// This example demonstrates Protocol Buffers usage in modern C++.
//
// TOPICS COVERED:
// 1. Creating and populating protobuf messages
// 2. Serialization to binary format
// 3. Deserialization from binary format
// 4. JSON conversion (protobuf v3 feature)
// 5. Nested messages and repeated fields
// 6. Enums and oneof fields
// 7. Performance and memory efficiency
// 8. Best practices for embedded systems
//
// WHAT IS PROTOCOL BUFFERS?
// - Language-neutral, platform-neutral serialization format
// - Smaller, faster, and simpler than XML/JSON
// - Generates code for multiple languages (C++, Python, Java, Go, etc.)
// - Backward/forward compatible with schema evolution
// - Used by Google, Netflix, Uber, and many others
//
// WHY USE PROTOBUF?
// ✅ Efficient: 3-10x smaller than XML, 20-100x faster
// ✅ Type-safe: Strong typing with generated code
// ✅ Versioned: Schema evolution with backward compatibility
// ✅ Cross-language: Same .proto file works for multiple languages
// ✅ Validated: Automatic validation of message structure
//
// BUILD REQUIREMENTS:
// - Google Protocol Buffers library (libprotobuf-dev)
// - protoc compiler to generate C++ code from .proto files
//
// ===================================================================

#include <iostream>
#include <fstream>
#include <memory>
#include <chrono>
#include <iomanip>

// Include generated protobuf headers
// These are generated by protoc from sensor_data.proto
// #include "sensor_data.pb.h"

// Include generated protobuf headers
// These are generated by protoc from sensor_data.proto
#include "sensor_data.pb.h"

// ===================================================================
// EXAMPLE 1: CREATING AND POPULATING MESSAGES
// ===================================================================

void example_create_sensor_reading() {
    std::cout << "=== Example 1: Creating Sensor Reading ===\n";
    
    // Create a temperature sensor reading
    sensors::SensorReading reading;
    
    // Set basic fields
    reading.set_type(sensors::TEMPERATURE);
    reading.set_device_id("sensor_001");
    
    // Set timestamp (current time)
    auto* timestamp = reading.mutable_timestamp();
    auto now = std::chrono::system_clock::now();
    auto epoch = now.time_since_epoch();
    timestamp->set_seconds(std::chrono::duration_cast<std::chrono::seconds>(epoch).count());
    timestamp->set_nanoseconds(0);
    
    // Set temperature measurement (using oneof field)
    reading.set_temperature_celsius(23.5f);
    
    // Add metadata
    (*reading.mutable_metadata())["location"] = "office";
    (*reading.mutable_metadata())["calibrated"] = "true";
    
    std::cout << "Created sensor reading:\n";
    std::cout << "  Device: " << reading.device_id() << "\n";
    std::cout << "  Type: " << reading.type() << "\n";
    std::cout << "  Temperature: " << reading.temperature_celsius() << "°C\n";
    std::cout << "  Metadata:\n";
    for (const auto& [key, value] : reading.metadata()) {
        std::cout << "    " << key << " = " << value << "\n";
    }
    
    std::cout << "\nKey features demonstrated:\n";
    std::cout << "  ✅ Simple field setters (set_xxx)\n";
    std::cout << "  ✅ Nested message creation (mutable_xxx)\n";
    std::cout << "  ✅ Oneof field (only one measurement type at a time)\n";
    std::cout << "  ✅ Map fields for flexible metadata\n\n";
}

// ===================================================================
// EXAMPLE 2: BINARY SERIALIZATION
// ===================================================================

void example_binary_serialization() {
    std::cout << "=== Example 2: Binary Serialization ===\n";
    
    sensors::SensorReading reading;
    reading.set_type(sensors::TEMPERATURE);
    reading.set_device_id("sensor_001");
    reading.set_temperature_celsius(23.5f);
    
    // Method 1: Serialize to string
    std::string serialized;
    if (!reading.SerializeToString(&serialized)) {
        std::cerr << "Failed to serialize!\n";
        return;
    }
    
    std::cout << "Serialized size: " << serialized.size() << " bytes\n";
    std::cout << "Binary data (hex): ";
    for (size_t i = 0; i < std::min(serialized.size(), size_t(20)); ++i) {
        printf("%02x ", (unsigned char)serialized[i]);
    }
    if (serialized.size() > 20) std::cout << "...";
    std::cout << "\n";
    
    // Method 2: Serialize to file
    std::ofstream output("sensor_data.bin", std::ios::binary);
    if (!reading.SerializeToOstream(&output)) {
        std::cerr << "Failed to write to file!\n";
        return;
    }
    output.close();
    std::cout << "✓ Written to sensor_data.bin\n";
    
    // Method 3: Serialize to byte array (for embedded systems)
    size_t size = reading.ByteSizeLong();
    std::vector<uint8_t> buffer(size);
    if (!reading.SerializeToArray(buffer.data(), size)) {
        std::cerr << "Failed to serialize to array!\n";
        return;
    }
    std::cout << "✓ Serialized to byte array (" << size << " bytes)\n";
    
    std::cout << "\nSerialization methods:\n";
    std::cout << "  1. SerializeToString() - for std::string storage\n";
    std::cout << "  2. SerializeToOstream() - for file I/O\n";
    std::cout << "  3. SerializeToArray() - for fixed buffers (embedded)\n";
    std::cout << "  4. ByteSizeLong() - get serialized size before writing\n\n";
}

// ===================================================================
// EXAMPLE 3: BINARY DESERIALIZATION
// ===================================================================

void example_binary_deserialization() {
    std::cout << "=== Example 3: Binary Deserialization ===\n";
    
    // First, create and serialize a message
    sensors::SensorReading original;
    original.set_type(sensors::HUMIDITY);
    original.set_device_id("sensor_002");
    original.set_humidity_percent(65.3f);
    
    std::string serialized_data;
    original.SerializeToString(&serialized_data);
    std::cout << "Original message serialized (" << serialized_data.size() << " bytes)\n";
    
    // Method 1: Deserialize from string
    sensors::SensorReading reading;
    if (!reading.ParseFromString(serialized_data)) {
        std::cerr << "Failed to parse!\n";
        return;
    }
    std::cout << "✓ Deserialized from string:\n";
    std::cout << "  Device: " << reading.device_id() << "\n";
    std::cout << "  Humidity: " << reading.humidity_percent() << "%\n";
    
    // Method 2: Deserialize from file
    std::ifstream input("sensor_data.bin", std::ios::binary);
    sensors::SensorReading reading2;
    if (input.good() && reading2.ParseFromIstream(&input)) {
        std::cout << "✓ Deserialized from file:\n";
        std::cout << "  Device: " << reading2.device_id() << "\n";
        std::cout << "  Temperature: " << reading2.temperature_celsius() << "°C\n";
    }
    input.close();
    
    // Method 3: Deserialize from byte array
    std::vector<uint8_t> buffer(serialized_data.begin(), serialized_data.end());
    sensors::SensorReading reading3;
    if (!reading3.ParseFromArray(buffer.data(), buffer.size())) {
        std::cerr << "Failed to parse from array!\n";
        return;
    }
    std::cout << "✓ Deserialized from byte array: " << reading3.device_id() << "\n";
    
    // Demonstrate field checking
    if (reading3.has_humidity_percent()) {
        std::cout << "  Has humidity field: " << reading3.humidity_percent() << "%\n";
    }
    
    std::cout << "\nDeserialization methods:\n";
    std::cout << "  1. ParseFromString() - from std::string\n";
    std::cout << "  2. ParseFromIstream() - from file\n";
    std::cout << "  3. ParseFromArray() - from buffer\n";
    std::cout << "  4. has_xxx() - check if optional field is set\n\n";
}

// ===================================================================
// EXAMPLE 4: JSON CONVERSION
// ===================================================================

void example_json_conversion() {
    std::cout << "=== Example 4: JSON Conversion (Protobuf v3) ===\n";
    
    std::cout << R"code(
#include <google/protobuf/util/json_util.h>

sensors::SensorReading reading;
reading.set_type(sensors::TEMPERATURE);
reading.set_device_id("sensor_001");
reading.set_temperature_celsius(23.5f);

// Convert to JSON
std::string json_output;
google::protobuf::util::JsonPrintOptions options;
options.add_whitespace = true;  // Pretty print
options.always_print_primitive_fields = true;  // Show all fields

auto status = google::protobuf::util::MessageToJsonString(
    reading, &json_output, options
);

if (status.ok()) {
    std::cout << "JSON output:\n" << json_output << "\n";
} else {
    std::cerr << "JSON conversion failed: " << status.message() << "\n";
}

// Convert from JSON
std::string json_input = R"({
    "type": "TEMPERATURE",
    "device_id": "sensor_002",
    "temperature_celsius": 25.3
})";

sensors::SensorReading parsed_reading;
status = google::protobuf::util::JsonStringToMessage(json_input, &parsed_reading);

if (status.ok()) {
    std::cout << "Parsed from JSON: " << parsed_reading.device_id() << "\n";
}
)code";
    
    std::cout << "\nJSON features:\n";
    std::cout << "  ✅ Human-readable debugging\n";
    std::cout << "  ✅ REST API compatibility\n";
    std::cout << "  ✅ Configuration files\n";
    std::cout << "  ⚠️ Larger than binary (use binary for production)\n\n";
}

// ===================================================================
// EXAMPLE 5: REPEATED FIELDS AND BATCHING
// ===================================================================

void example_repeated_fields() {
    std::cout << "=== Example 5: Repeated Fields (Batch Processing) ===\n";
    
    sensors::SensorBatch batch;
    batch.set_batch_id("batch_001");
    
    // Add multiple sensor readings
    for (int i = 0; i < 10; ++i) {
        auto* reading = batch.add_readings();  // Add new reading
        reading->set_type(sensors::TEMPERATURE);
        reading->set_device_id("sensor_" + std::to_string(i));
        reading->set_temperature_celsius(20.0f + i * 0.5f);
    }
    
    // Iterate over readings
    std::cout << "Batch contains " << batch.readings_size() << " readings:\n";
    for (const auto& reading : batch.readings()) {
        std::cout << "  " << reading.device_id() 
                  << ": " << reading.temperature_celsius() << "°C\n";
    }
    
    // Access by index
    if (batch.readings_size() > 0) {
        const auto& first = batch.readings(0);
        std::cout << "\nFirst reading: " << first.device_id() << "\n";
    }
    
    // Serialize the batch
    std::string batch_data;
    batch.SerializeToString(&batch_data);
    std::cout << "Batch serialized: " << batch_data.size() << " bytes for " 
              << batch.readings_size() << " readings\n";
    std::cout << "Average: " << (batch_data.size() / batch.readings_size()) << " bytes/reading\n";
    
    std::cout << "\nRepeated field methods:\n";
    std::cout << "  • add_xxx() - append new element\n";
    std::cout << "  • xxx_size() - get count\n";
    std::cout << "  • xxx(index) - access by index\n";
    std::cout << "  • clear_xxx() - remove all elements\n";
    std::cout << "  • Range-based for loop support\n\n";
}

// ===================================================================
// EXAMPLE 6: MEMORY MANAGEMENT AND PERFORMANCE
// ===================================================================

void example_performance() {
    std::cout << "=== Example 6: Performance and Memory Efficiency ===\n";
    
    std::cout << R"(
// Arena allocation for high-performance scenarios
// Reduces memory allocations and improves cache locality
google::protobuf::Arena arena;

auto* reading = google::protobuf::Arena::CreateMessage<sensors::SensorReading>(&arena);
reading->set_device_id("sensor_001");
reading->set_temperature_celsius(23.5f);

// All nested messages also use arena
auto* timestamp = reading->mutable_timestamp();
timestamp->set_seconds(12345);

// Memory is freed when arena goes out of scope
// No need to delete individual messages

// Performance tips:
// 1. Reuse message objects instead of creating new ones
sensors::SensorReading reusable_msg;
for (int i = 0; i < 1000; ++i) {
    reusable_msg.Clear();  // Reset, don't recreate
    reusable_msg.set_device_id("sensor_" + std::to_string(i));
    // ... serialize and send ...
}

// 2. Use SerializeToArray with pre-allocated buffer
std::vector<uint8_t> buffer(1024);  // Pre-allocate
size_t size = reading->ByteSizeLong();
if (size <= buffer.size()) {
    reading->SerializeToArray(buffer.data(), size);
}

// 3. For embedded systems: use lite runtime
// In .proto file: option optimize_for = LITE_RUNTIME;
// Reduces binary size by 50-70%
)";
    
    std::cout << "\nPerformance techniques:\n";
    std::cout << "  ✅ Arena allocation - reduces fragmentation\n";
    std::cout << "  ✅ Message reuse with Clear() - avoids allocations\n";
    std::cout << "  ✅ Pre-allocated buffers - zero-copy serialization\n";
    std::cout << "  ✅ Lite runtime - smaller binary for embedded systems\n";
    std::cout << "  ✅ Lazy field evaluation - on-demand parsing\n\n";
}

// ===================================================================
// EXAMPLE 7: EMBEDDED SYSTEMS BEST PRACTICES
// ===================================================================

void example_embedded_systems() {
    std::cout << "=== Example 7: Embedded Systems Best Practices ===\n";
    
    std::cout << R"(
// 1. Use fixed-size buffers to avoid dynamic allocation
constexpr size_t MAX_MESSAGE_SIZE = 256;
uint8_t tx_buffer[MAX_MESSAGE_SIZE];
uint8_t rx_buffer[MAX_MESSAGE_SIZE];

// 2. Serialize directly to UART/SPI buffer
sensors::SensorReading reading;
reading.set_device_id("mcu_001");
reading.set_temperature_celsius(23.5f);

size_t size = reading.ByteSizeLong();
if (size <= MAX_MESSAGE_SIZE) {
    reading.SerializeToArray(tx_buffer, size);
    // uart_transmit(tx_buffer, size);
}

// 3. Parse from received buffer
// size_t received = uart_receive(rx_buffer, MAX_MESSAGE_SIZE);
size_t received = 50;  // Example

sensors::SensorReading received_msg;
if (received_msg.ParseFromArray(rx_buffer, received)) {
    // Process message
    float temp = received_msg.temperature_celsius();
}

// 4. Use lite runtime for small footprint
// .proto file option:
//   option optimize_for = LITE_RUNTIME;
// 
// Removes:
// - Reflection API
// - Text format support  
// - JSON conversion
//
// Result: 50-70% smaller binary

// 5. Error handling without exceptions (embedded systems)
#ifdef PROTOBUF_USE_EXCEPTIONS
    try {
        reading.ParseFromArray(rx_buffer, received);
    } catch (const std::exception& e) {
        // Handle error
    }
#else
    // Check return value
    if (!reading.ParseFromArray(rx_buffer, received)) {
        // Handle error without exceptions
    }
#endif
)";
    
    std::cout << "\nEmbedded systems considerations:\n";
    std::cout << "  ✅ Fixed-size buffers - no heap fragmentation\n";
    std::cout << "  ✅ Lite runtime - minimal binary size\n";
    std::cout << "  ✅ No exceptions - suitable for bare-metal\n";
    std::cout << "  ✅ Zero-copy serialization - DMA-friendly\n";
    std::cout << "  ✅ Deterministic memory usage\n\n";
}

// ===================================================================
// EXAMPLE 8: SCHEMA EVOLUTION (BACKWARD COMPATIBILITY)
// ===================================================================

void example_schema_evolution() {
    std::cout << "=== Example 8: Schema Evolution ===\n";
    
    std::cout << R"(
// Protocol Buffers support schema evolution:
// Old code can read new messages, new code can read old messages

// VERSION 1 of .proto:
// message SensorReading {
//   string device_id = 1;
//   float temperature_celsius = 2;
// }

// VERSION 2 adds new fields (backward compatible):
// message SensorReading {
//   string device_id = 1;
//   float temperature_celsius = 2;
//   string location = 3;        // NEW FIELD
//   int32 battery_percent = 4;  // NEW FIELD
// }

// Rules for compatibility:
// ✅ Can add new fields (old code ignores them)
// ✅ Can remove optional fields (new code uses defaults)
// ❌ Cannot change field numbers (breaks everything)
// ❌ Cannot change field types (incompatible)
// ⚠️ Can rename fields (only changes code, not wire format)

// Example: Old client reading new message
// sensors::SensorReading msg;  // From version 1 code
// msg.ParseFromString(new_message_bytes);
// 
// float temp = msg.temperature_celsius();  // Works!
// // New fields (location, battery) are ignored by old code

// Example: New client reading old message
// sensors::SensorReading msg;  // From version 2 code
// msg.ParseFromString(old_message_bytes);
//
// float temp = msg.temperature_celsius();  // Works!
// std::string loc = msg.location();         // Empty string (default)
// int battery = msg.battery_percent();      // 0 (default)
)";
    
    std::cout << "\nBackward compatibility rules:\n";
    std::cout << "  DO:\n";
    std::cout << "    ✅ Add new optional fields\n";
    std::cout << "    ✅ Remove optional fields (deprecated first)\n";
    std::cout << "    ✅ Rename fields (code only, not wire format)\n";
    std::cout << "  DON'T:\n";
    std::cout << "    ❌ Change field numbers\n";
    std::cout << "    ❌ Change field types\n";
    std::cout << "    ❌ Make required fields optional (v2 syntax)\n\n";
}

// ===================================================================
// COMPARISON: PROTOBUF VS ALTERNATIVES
// ===================================================================

void comparison_with_alternatives() {
    std::cout << "=== Comparison with Alternatives ===\n\n";
    
    std::cout << "XML:\n";
    std::cout << "  ❌ 3-10x larger than protobuf\n";
    std::cout << "  ❌ 20-100x slower parsing\n";
    std::cout << "  ✅ Human-readable\n";
    std::cout << "  ✅ Self-describing\n\n";
    
    std::cout << "JSON:\n";
    std::cout << "  ❌ 2-5x larger than protobuf\n";
    std::cout << "  ❌ 10-50x slower parsing\n";
    std::cout << "  ✅ Human-readable\n";
    std::cout << "  ✅ JavaScript-friendly\n";
    std::cout << "  ❌ No schema enforcement\n\n";
    
    std::cout << "MessagePack:\n";
    std::cout << "  ✅ Similar size to protobuf\n";
    std::cout << "  ✅ Fast parsing\n";
    std::cout << "  ❌ No schema (schemaless)\n";
    std::cout << "  ❌ No code generation\n\n";
    
    std::cout << "FlatBuffers:\n";
    std::cout << "  ✅ Zero-copy deserialization\n";
    std::cout << "  ✅ Very fast access\n";
    std::cout << "  ⚠️ Larger than protobuf\n";
    std::cout << "  ⚠️ Mutable messages more complex\n\n";
    
    std::cout << "Cap'n Proto:\n";
    std::cout << "  ✅ Zero-copy like FlatBuffers\n";
    std::cout << "  ✅ Very fast\n";
    std::cout << "  ⚠️ Less mature ecosystem\n";
    std::cout << "  ⚠️ Smaller community\n\n";
    
    std::cout << "When to use Protocol Buffers:\n";
    std::cout << "  ✅ Need efficient binary serialization\n";
    std::cout << "  ✅ Cross-language communication\n";
    std::cout << "  ✅ Schema evolution important\n";
    std::cout << "  ✅ Google's ecosystem (gRPC, etc.)\n";
    std::cout << "  ✅ Embedded systems with constraints\n\n";
}

// ===================================================================
// MAIN FUNCTION
// ===================================================================

int main() {
    std::cout << "=========================================================\n";
    std::cout << "GOOGLE PROTOCOL BUFFERS (PROTOBUF) EXAMPLES\n";
    std::cout << "=========================================================\n\n";
    
    example_create_sensor_reading();
    example_binary_serialization();
    example_binary_deserialization();
    example_json_conversion();
    example_repeated_fields();
    example_performance();
    example_embedded_systems();
    example_schema_evolution();
    comparison_with_alternatives();
    
    std::cout << "=========================================================\n";
    std::cout << "BUILD INSTRUCTIONS:\n";
    std::cout << "=========================================================\n\n";
    
    std::cout << "1. Install Protocol Buffers:\n";
    std::cout << "   Ubuntu/Debian:\n";
    std::cout << "     sudo apt-get install protobuf-compiler libprotobuf-dev\n\n";
    
    std::cout << "   macOS:\n";
    std::cout << "     brew install protobuf\n\n";
    
    std::cout << "   Windows:\n";
    std::cout << "     Download from: https://github.com/protocolbuffers/protobuf/releases\n\n";
    
    std::cout << "2. Generate C++ code from .proto file:\n";
    std::cout << "   protoc --cpp_out=. proto/sensor_data.proto\n";
    std::cout << "   This creates:\n";
    std::cout << "     - sensor_data.pb.h\n";
    std::cout << "     - sensor_data.pb.cc\n\n";
    
    std::cout << "3. Compile with CMake:\n";
    std::cout << "   find_package(Protobuf REQUIRED)\n";
    std::cout << "   target_link_libraries(YourTarget protobuf::libprotobuf)\n\n";
    
    std::cout << "4. Or compile manually:\n";
    std::cout << "   g++ -std=c++17 ProtobufExample.cpp sensor_data.pb.cc \\\n";
    std::cout << "       -lprotobuf -o protobuf_example\n\n";
    
    std::cout << "=========================================================\n";
    std::cout << "RESOURCES:\n";
    std::cout << "=========================================================\n";
    std::cout << "Official docs: https://protobuf.dev/\n";
    std::cout << "GitHub: https://github.com/protocolbuffers/protobuf\n";
    std::cout << "C++ tutorial: https://protobuf.dev/getting-started/cpptutorial/\n\n";
    
    return 0;
}
